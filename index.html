<!DOCTYPE html>
<html>
	<head>
		<title> HanoiTowerMind </title>
	</head>

	<body>
		<address> 
			Written by Sean Smith. <br>
			Date: <time datetime="2012-12-12"> 12/12/2012 </time><br><br>
			Module:   CA318 - Advanced Algorithms and AI Search <br>
			Course:   B.Sc. in Computer Applications (Bachelor Honours Degree)<br>
		</address>
		
		<br>
		<h2> HanoiTower Description </h2>
			<a href="hanoi_tower_description.html"> Click to read World's description </a>
		
		<h2> HanoiTower Mind </h2>
			<a href="hanoi_mind_description.html"> Click to view source code of Hanoi Tower Mind </a>
			
		<br>
		<br>
		
		<h2 style="text-align:center"> Assignment Specification </h2>
		<p> Write a Mind for a selected World (i.e. Hanoi Tower). The purpose of the Mind is to solve the World's problem in the shortest number of moves. <br>
			The problem is to be solved using any desired method (hand-coded, search, etc...) and is to be coded in the Java programming language. <br><br>
			
			From an AI point of view, this illustrates a problem as the World has been previously coded to include specific actions and states which limits the possible solutions to the problem.<br>
			The priority of this assignment is to create an intelligent mind that can learn and understand its surroundings. This challenge is extremely difficult but creating an optimal solution can lead to countless benefits.<br>
			Unfortunately adapting an optimal solution to a World with predefined states and actions is vastly complicated in completing.
		</p>
		
		<br>
		
		<h2 style="text-align:center"> Assignment Research </h2>
		<p>
			In order to create an learning mind, a reliable and efficient world is required. Hanoi Tower is a reliable World, however the World lacks efficiency. <br>
			The Hanoi Tower problem is a unique problem to pursue a solution to. </p>
			
			There are 3 approaches to the problem:
			<ol>
				<li> <b>Predictability</b> 
				<li> <b>Recursion</b>
				<li> <b>Mathematical</b>
			</ol>
			
			<h4> <i><u>Predictability</u></i></h4>
				The Hanoi Tower World is a reliable world with a fixed state at the beginning of the Mind. <br>
				By collaborating with the Actions and States of the World, the optimal solution can be solved in advance of the Mind's initialisation. <br>
				A solution can generated by ensuring that all possible outcomes are foreseen and acted upon. This assists in determining that all scenario's the World has created, are solved. <br>
			
			<h4><i><u> Recursion </u></i></h4>
				The Hanoi Tower problem can be solved with recursion. The solution is highly optimal in terms of time complexity and adapting to other Worlds with a different number of disks. <br>
				<br>
				The following algorithm (pseudocode) can be used to solve the Hanoi Tower problem:
				<ul>
					<b><i> Solve(N, Source, Temp, Destination) <br> 
					{ <br>
						<ul>if(N is 0) <br> 
							<ul>exit <br>
							</ul>
						
						else{<ul> <br>
							Solve(N - 1, Source, Destination, Temp) <br>
							Move from Source to Destination <br>
							Solve(N - 1, Temp, Source, Destination) <br>
								</ul>
						} <br>
					</ul>
					} <br>
					</i></b>
				</ul>				
				This technique was not encoded due to the Actions and States provided within the World were not sufficient, nor adaptable, in completing this recursion procedure. <br>
			
			<h4><i><u> Mathematical </u></i></h4>
				By researching my predictability solution, I discovered interesting findings in terms of mathematical solutions.
				Originally I produced the following pages when researching my solution to the World.
				
				<ul><b> State Calculations </b><br>
				<a href="state_calculations.html">State Calculations</a>
				</ul>
				
				<ul><b> State Patterns </b></br>
					<a href="state_patterns.html">State Patterns</a><br><br>
					
					The calculations produced in "State Calculations" are exploited to develop a pattern, represented in "State Patterns"
				</ul>
				<br>
				Unfortunately the pattern identified could not be developed into a sufficient algorithm, due to the Actions of the game not having an identical pattern. <br>
				This approach was not pursued, as this would have led to a large if-else statement, which would have generated a large time complexity. 
			
			<br><br>
			<h2 style="text-align:center"> Assignment Solution </h2>
			
			I realised that, due to Actions provided in the World, my efforts should be focused primarily on more basic solutions, rather than complex solutions. <br>
			The reason for this is because there is an extremely limited number of solutions for this World, due to strict Actions and States being enforced. <br><br>
			
			As a result of this decision, I decided to pursue the predictability approach. <br>
			Before I began coding, I wrote out all possible steps to get from Peg A to Peg B or Peg C. Upon my research, I discovered that the shortest way to solve the problem is '2n - 1'. <br>
			I wrote down a successful step-by-step approach that led to a total number of moves of 31. This satisfies the shortest solution: 2(5) - 1 = 31. <br> <br>
			
			When I was satisfied that I had explored the most optimal steps, I transformed my solution into code. <br>
			I wished to invoke a more intelligent solution, rather than a list of Actions called in the correct order. <br>
			My ideal scenario was to allow the Mind to check if the rings were all on a correct peg. Each step of the solution was unique, this avoided any confliction in the process. <br><br>
			
			For simplicity reasons, I split the scenario's into their own private methods. Each method indicated what Action was to be invoked by the Mind. <br>
			Upon the completion of the source code, the Mind runs in a recursive state, constantly checking and choosing the correct moves.  
			
	</body>
</html>